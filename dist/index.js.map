{"version":3,"file":"index.js","sources":["../node_modules/wildemitter/wildemitter.js","../node_modules/hark/hark.js","../node_modules/inline-worker/index.js","../src/Hooks/recorder.js","../src/Hooks/recorderHelpers.js","../src/Hooks/index.tsx"],"sourcesContent":["/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n","var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n","var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\n\nfunction InlineWorker(func, self) {\n  var _this = this;\n  var functionBody;\n\n  self = self || {};\n\n  if (WORKER_ENABLED) {\n    functionBody = func.toString().trim().match(\n      /^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/\n    )[1];\n\n    return new global.Worker(global.URL.createObjectURL(\n      new global.Blob([ functionBody ], { type: \"text/javascript\" })\n    ));\n  }\n\n  function postMessage(data) {\n    setTimeout(function() {\n      _this.onmessage({ data: data });\n    }, 0);\n  }\n\n  this.self = self;\n  this.self.postMessage = postMessage;\n\n  setTimeout(func.bind(self, self), 0);\n}\n\nInlineWorker.prototype.postMessage = function postMessage(data) {\n  var _this = this;\n\n  setTimeout(function() {\n    _this.self.onmessage({ data: data });\n  }, 0);\n};\n\nmodule.exports = InlineWorker;\n","import InlineWorker from 'inline-worker';\r\n\r\nexport class Recorder {\r\n  constructor(source, cfg) {\r\n    this.config = {\r\n      bufferLen: 4096,\r\n      numChannels: 1,\r\n      mimeType: 'audio/wav',\r\n      ...cfg\r\n    };\r\n    this.recording = false;\r\n    this.callbacks = {\r\n      getBuffer: [],\r\n      exportWAV: []\r\n    };\r\n    this.context = source.context;\r\n    this.node = (\r\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\r\n    ).call(\r\n      this.context,\r\n      this.config.bufferLen,\r\n      this.config.numChannels,\r\n      this.config.numChannels\r\n    );\r\n\r\n    this.node.onaudioprocess = (e) => {\r\n      if (!this.recording) return;\r\n\r\n      var buffer = [];\r\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\r\n        buffer.push(e.inputBuffer.getChannelData(channel));\r\n      }\r\n      this.worker.postMessage({\r\n        command: 'record',\r\n        buffer: buffer\r\n      });\r\n    };\r\n\r\n    source.connect(this.node);\r\n    this.node.connect(this.context.destination); //this should not be necessary\r\n\r\n    let self = {};\r\n    this.worker = new InlineWorker(function () {\r\n      let recLength = 0,\r\n        recBuffers = [],\r\n        sampleRate,\r\n        numChannels;\r\n\r\n      this.onmessage = function (e) {\r\n        switch (e.data.command) {\r\n          case 'init':\r\n            init(e.data.config);\r\n            break;\r\n          case 'record':\r\n            record(e.data.buffer);\r\n            break;\r\n          case 'exportWAV':\r\n            exportWAV(e.data.type);\r\n            break;\r\n          case 'getBuffer':\r\n            getBuffer();\r\n            break;\r\n          case 'clear':\r\n            clear();\r\n            break;\r\n        }\r\n      };\r\n\r\n      let newSampleRate;\r\n\r\n      function init(config) {\r\n        sampleRate = config.sampleRate;\r\n        numChannels = config.numChannels;\r\n        initBuffers();\r\n\r\n        if (sampleRate > 48000) {\r\n          newSampleRate = 48000;\r\n        } else {\r\n          newSampleRate = sampleRate;\r\n        }\r\n      }\r\n\r\n      function record(inputBuffer) {\r\n        for (var channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel].push(inputBuffer[channel]);\r\n        }\r\n        recLength += inputBuffer[0].length;\r\n      }\r\n\r\n      function exportWAV(type) {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        let interleaved;\r\n        if (numChannels === 2) {\r\n          interleaved = interleave(buffers[0], buffers[1]);\r\n        } else {\r\n          interleaved = buffers[0];\r\n        }\r\n\r\n        // converts sample rate to 48000 if higher than 48000\r\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\r\n\r\n        let dataview = encodeWAV(downSampledBuffer);\r\n        let audioBlob = new Blob([dataview], { type: type });\r\n\r\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\r\n      }\r\n\r\n      function getBuffer() {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        this.postMessage({ command: 'getBuffer', data: buffers });\r\n      }\r\n\r\n      function clear() {\r\n        recLength = 0;\r\n        recBuffers = [];\r\n        initBuffers();\r\n      }\r\n\r\n      function initBuffers() {\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel] = [];\r\n        }\r\n      }\r\n\r\n      function mergeBuffers(recBuffers, recLength) {\r\n        let result = new Float32Array(recLength);\r\n        let offset = 0;\r\n        for (let i = 0; i < recBuffers.length; i++) {\r\n          result.set(recBuffers[i], offset);\r\n          offset += recBuffers[i].length;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function interleave(inputL, inputR) {\r\n        let length = inputL.length + inputR.length;\r\n        let result = new Float32Array(length);\r\n\r\n        let index = 0,\r\n          inputIndex = 0;\r\n\r\n        while (index < length) {\r\n          result[index++] = inputL[inputIndex];\r\n          result[index++] = inputR[inputIndex];\r\n          inputIndex++;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function floatTo16BitPCM(output, offset, input) {\r\n        for (let i = 0; i < input.length; i++, offset += 2) {\r\n          let s = Math.max(-1, Math.min(1, input[i]));\r\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n        }\r\n      }\r\n\r\n      function writeString(view, offset, string) {\r\n        for (let i = 0; i < string.length; i++) {\r\n          view.setUint8(offset + i, string.charCodeAt(i));\r\n        }\r\n      }\r\n\r\n      // Down sample buffer before WAV encoding\r\n      function downSampleBuffer(buffer, rate) {\r\n        if (rate == sampleRate) {\r\n          return buffer;\r\n        }\r\n        if (rate > sampleRate) {\r\n          throw 'downsampling rate show be smaller than original sample rate';\r\n        }\r\n        var sampleRateRatio = sampleRate / rate;\r\n        var newLength = Math.round(buffer.length / sampleRateRatio);\r\n        var result = new Float32Array(newLength);\r\n        var offsetResult = 0;\r\n        var offsetBuffer = 0;\r\n        while (offsetResult < result.length) {\r\n          var nextOffsetBuffer = Math.round(\r\n            (offsetResult + 1) * sampleRateRatio\r\n          );\r\n          // Use average value of skipped samples\r\n          var accum = 0,\r\n            count = 0;\r\n          for (\r\n            var i = offsetBuffer;\r\n            i < nextOffsetBuffer && i < buffer.length;\r\n            i++\r\n          ) {\r\n            accum += buffer[i];\r\n            count++;\r\n          }\r\n          result[offsetResult] = accum / count;\r\n          // Or you can simply get rid of the skipped samples:\r\n          // result[offsetResult] = buffer[nextOffsetBuffer];\r\n          offsetResult++;\r\n          offsetBuffer = nextOffsetBuffer;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function encodeWAV(samples) {\r\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\r\n        let view = new DataView(buffer);\r\n\r\n        /* RIFF identifier */\r\n        writeString(view, 0, 'RIFF');\r\n        /* RIFF chunk length */\r\n        view.setUint32(4, 36 + samples.length * 2, true);\r\n        /* RIFF type */\r\n        writeString(view, 8, 'WAVE');\r\n        /* format chunk identifier */\r\n        writeString(view, 12, 'fmt ');\r\n        /* format chunk length */\r\n        view.setUint32(16, 16, true);\r\n        /* sample format (raw) */\r\n        view.setUint16(20, 1, true);\r\n        /* channel count */\r\n        view.setUint16(22, numChannels, true);\r\n        /* sample rate */\r\n        view.setUint32(24, newSampleRate, true);\r\n        /* byte rate (sample rate * block align) */\r\n        view.setUint32(28, newSampleRate * 4, true);\r\n        /* block align (channel count * bytes per sample) */\r\n        view.setUint16(32, numChannels * 2, true);\r\n        /* bits per sample */\r\n        view.setUint16(34, 16, true);\r\n        /* data chunk identifier */\r\n        writeString(view, 36, 'data');\r\n        /* data chunk length */\r\n        view.setUint32(40, samples.length * 2, true);\r\n\r\n        floatTo16BitPCM(view, 44, samples);\r\n\r\n        return view;\r\n      }\r\n    }, self);\r\n\r\n    this.worker.postMessage({\r\n      command: 'init',\r\n      config: {\r\n        sampleRate: this.context.sampleRate,\r\n        numChannels: this.config.numChannels\r\n      }\r\n    });\r\n\r\n    this.worker.onmessage = (e) => {\r\n      let cb = this.callbacks[e.data.command].pop();\r\n      if (typeof cb == 'function') {\r\n        cb(e.data.data);\r\n      }\r\n    };\r\n  }\r\n\r\n  record() {\r\n    this.recording = true;\r\n  }\r\n\r\n  stop() {\r\n    this.recording = false;\r\n  }\r\n\r\n  clear() {\r\n    this.worker.postMessage({ command: 'clear' });\r\n  }\r\n\r\n  getBuffer(cb) {\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error('Callback not set');\r\n\r\n    this.callbacks.getBuffer.push(cb);\r\n\r\n    this.worker.postMessage({ command: 'getBuffer' });\r\n  }\r\n\r\n  exportWAV(cb, mimeType) {\r\n    mimeType = mimeType || this.config.mimeType;\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error('Callback not set');\r\n\r\n    this.callbacks.exportWAV.push(cb);\r\n\r\n    this.worker.postMessage({\r\n      command: 'exportWAV',\r\n      type: mimeType\r\n    });\r\n  }\r\n\r\n  static forceDownload(blob, filename) {\r\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\r\n    let link = window.document.createElement('a');\r\n    link.href = url;\r\n    link.download = filename || 'output.wav';\r\n    let click = document.createEvent('Event');\r\n    click.initEvent('click', true, true);\r\n    link.dispatchEvent(click);\r\n  }\r\n}\r\n\r\nexport default Recorder;\r\n","import Recorder from './recorder';\r\n\r\nlet microphoneStream; // stream from getUserMedia()\r\nlet rec = Recorder; // Recorder.js object\r\nlet input; // MediaStreamAudioSourceNode we'll be recording\r\n\r\n/**\r\n *\r\n * @param {{\r\n * audioContext: AudioContext\r\n * errHandler?: () => void\r\n * onStreamLoad?: () => void\r\n * }}\r\n * @returns {Promise<MediaStream>}\r\n */\r\nexport async function startRecording({\r\n  audioContext,\r\n  errHandler,\r\n  onStreamLoad,\r\n}) {\r\n  try {\r\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n    if (onStreamLoad) {\r\n      onStreamLoad();\r\n    }\r\n\r\n    /*  assign stream for later use  */\r\n    microphoneStream = stream;\r\n\r\n    /* use the stream */\r\n    input = audioContext.createMediaStreamSource(stream);\r\n\r\n    rec = new Recorder(input);\r\n\r\n    // start the recording process\r\n    rec.record();\r\n\r\n    return stream;\r\n  } catch (err) {\r\n    console.log(err);\r\n\r\n    if (errHandler) {\r\n      errHandler();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {{\r\n * exportWAV: boolean\r\n * wavCallback?: (blob: Blob) => void\r\n * }}\r\n */\r\nexport function stopRecording({ exportWAV, wavCallback }) {\r\n  // stop recorder.js recording\r\n  rec.stop();\r\n\r\n  // stop microphone access\r\n  microphoneStream.getAudioTracks()[0].stop();\r\n\r\n  // create the wav blob\r\n  if (exportWAV && wavCallback) {\r\n    rec.exportWAV((blob) => wavCallback(blob));\r\n  }\r\n\r\n  rec.clear();\r\n}\r\n","import { useState, useEffect, useRef } from 'react';\r\nimport Hark from 'hark';\r\nimport { startRecording, stopRecording } from './recorderHelpers';\r\n\r\n// https://cloud.google.com/speech-to-text/docs/reference/rest/v1/RecognitionConfig\r\nimport { GoogleCloudRecognitionConfig } from './GoogleCloudRecognitionConfig';\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition\r\nexport interface SpeechRecognitionProperties {\r\n  // continuous: do not pass continuous here, instead pass it as a param to the hook\r\n  grammars?: SpeechGrammarList;\r\n  interimResults?: boolean;\r\n  lang?: string;\r\n  maxAlternatives?: number;\r\n}\r\n\r\ninterface BraveNavigator extends Navigator {\r\n  brave: {\r\n    isBrave: () => Promise<boolean>;\r\n  };\r\n}\r\n\r\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\r\n\r\nconst SpeechRecognition =\r\n  window.SpeechRecognition || (window as any).webkitSpeechRecognition;\r\n\r\nlet recognition: SpeechRecognition | null;\r\n\r\nexport type ResultType = {\r\n  speechBlob?: Blob;\r\n  timestamp: number;\r\n  transcript: string;\r\n};\r\n\r\n// Set recognition back to null for brave browser due to promise resolving\r\n// after the conditional on line 31\r\nif ((navigator as BraveNavigator).brave) {\r\n  (navigator as BraveNavigator).brave.isBrave().then((bool) => {\r\n    if (bool) recognition = null;\r\n  });\r\n}\r\n\r\n// Chromium browsers will have the SpeechRecognition method\r\n// but do not implement the functionality due to google wanting ðŸ’°\r\n// this covers new Edge and line 22 covers Brave, the two most popular non-chrome chromium browsers\r\nif (SpeechRecognition) {\r\n  recognition = new SpeechRecognition();\r\n}\r\n\r\nexport interface UseSpeechToTextTypes {\r\n  continuous?: boolean;\r\n  crossBrowser?: boolean;\r\n  googleApiKey?: string;\r\n  googleCloudRecognitionConfig?: GoogleCloudRecognitionConfig;\r\n  onStartSpeaking?: () => any;\r\n  onStoppedSpeaking?: () => any;\r\n  speechRecognitionProperties?: SpeechRecognitionProperties;\r\n  timeout?: number;\r\n  useLegacyResults?: boolean;\r\n  useOnlyGoogleCloud?: boolean;\r\n}\r\n\r\nexport default function useSpeechToText({\r\n  continuous,\r\n  crossBrowser,\r\n  googleApiKey,\r\n  googleCloudRecognitionConfig,\r\n  onStartSpeaking,\r\n  onStoppedSpeaking,\r\n  speechRecognitionProperties = { interimResults: true },\r\n  timeout = 10000,\r\n  useOnlyGoogleCloud = false,\r\n  useLegacyResults = true\r\n}: UseSpeechToTextTypes) {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n\r\n  const audioContextRef = useRef<AudioContext>();\r\n\r\n  const [legacyResults, setLegacyResults] = useState<string[]>([]);\r\n  const [results, setResults] = useState<ResultType[]>([]);\r\n\r\n  const [interimResult, setInterimResult] = useState<string | undefined>();\r\n  const [error, setError] = useState('');\r\n\r\n  const timeoutId = useRef<number>();\r\n  const mediaStream = useRef<MediaStream>();\r\n\r\n  useEffect(() => {\r\n    if (!crossBrowser && !recognition) {\r\n      setError(\r\n        'Speech Recognition API is only available on Chrome and Edge browsers'\r\n      );\r\n    }\r\n\r\n    if (!navigator?.mediaDevices?.getUserMedia) {\r\n      setError('getUserMedia is not supported on this device/browser :(');\r\n    }\r\n\r\n    if ((crossBrowser || useOnlyGoogleCloud) && !googleApiKey) {\r\n      console.error(\r\n        'No google cloud API key was passed, google API will not be able to process speech'\r\n      );\r\n    }\r\n\r\n    if (!audioContextRef.current) {\r\n      audioContextRef.current = new AudioContext();\r\n    }\r\n\r\n    if (useLegacyResults) {\r\n      console.warn(\r\n        'react-hook-speech-to-text is using legacy results, pass useLegacyResults: false to the hook to use the new array of objects results. Legacy array of strings results will be removed in a future version.'\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  // Chrome Speech Recognition API:\r\n  // Only supported on Chrome browsers\r\n  const chromeSpeechRecognition = () => {\r\n    if (recognition) {\r\n      // Continuous recording after stopped speaking event\r\n      if (continuous) recognition.continuous = true;\r\n\r\n      const { grammars, interimResults, lang, maxAlternatives } =\r\n        speechRecognitionProperties || {};\r\n\r\n      if (grammars) recognition.grammars = grammars;\r\n      if (lang) recognition.lang = lang;\r\n\r\n      recognition.interimResults = interimResults || false;\r\n      recognition.maxAlternatives = maxAlternatives || 1;\r\n\r\n      // start recognition\r\n      recognition.start();\r\n\r\n      // speech successfully translated into text\r\n      recognition.onresult = (e) => {\r\n        const result = e.results[e.results.length - 1];\r\n        const { transcript } = result[0];\r\n\r\n        const timestamp = Math.floor(Date.now() / 1000);\r\n\r\n        // Allows for realtime speech result UI feedback\r\n        if (interimResults) {\r\n          if (result.isFinal) {\r\n            setInterimResult(undefined);\r\n            setResults((prevResults) => [\r\n              ...prevResults,\r\n              { transcript, timestamp }\r\n            ]);\r\n            setLegacyResults((prevResults) => [...prevResults, transcript]);\r\n          } else {\r\n            let concatTranscripts = '';\r\n\r\n            // If continuous: e.results will include previous speech results: need to start loop at the current event resultIndex for proper concatenation\r\n            for (let i = e.resultIndex; i < e.results.length; i++) {\r\n              concatTranscripts += e.results[i][0].transcript;\r\n            }\r\n\r\n            setInterimResult(concatTranscripts);\r\n          }\r\n        } else {\r\n          setResults((prevResults) => [\r\n            ...prevResults,\r\n            { transcript, timestamp }\r\n          ]);\r\n          setLegacyResults((prevResults) => [...prevResults, transcript]);\r\n        }\r\n      };\r\n\r\n      recognition.onaudiostart = () => setIsRecording(true);\r\n\r\n      // Audio stopped recording or timed out.\r\n      // Chrome speech auto times-out if no speech after a while\r\n      recognition.onend = () => {\r\n        setIsRecording(false);\r\n      };\r\n    }\r\n  };\r\n\r\n  const startSpeechToText = async () => {\r\n    if (!useOnlyGoogleCloud && recognition) {\r\n      chromeSpeechRecognition();\r\n      return;\r\n    }\r\n\r\n    if (!crossBrowser && !useOnlyGoogleCloud) {\r\n      return;\r\n    }\r\n\r\n    // Resume audio context due to google auto play policy\r\n    // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio\r\n    if (audioContextRef.current?.state === 'suspended') {\r\n      audioContextRef.current?.resume();\r\n    }\r\n\r\n    const stream = await startRecording({\r\n      errHandler: () => setError('Microphone permission was denied'),\r\n      audioContext: audioContextRef.current as AudioContext\r\n    });\r\n\r\n    setIsRecording(true);\r\n\r\n    // Stop recording if timeout\r\n    if (timeout) {\r\n      clearTimeout(timeoutId.current);\r\n      handleRecordingTimeout();\r\n    }\r\n\r\n    // stop previous mediaStream track if exists\r\n    if (mediaStream.current) {\r\n      stopMediaStream();\r\n    }\r\n\r\n    // Clones stream to fix hark bug on Safari\r\n    mediaStream.current = stream.clone();\r\n\r\n    const speechEvents = Hark(mediaStream.current, {\r\n      audioContext: audioContextRef.current as AudioContext\r\n    });\r\n\r\n    speechEvents.on('speaking', () => {\r\n      if (onStartSpeaking) onStartSpeaking();\r\n\r\n      // Clear previous recording timeout on every speech event\r\n      clearTimeout(timeoutId.current);\r\n    });\r\n\r\n    speechEvents.on('stopped_speaking', () => {\r\n      if (onStoppedSpeaking) onStoppedSpeaking();\r\n\r\n      // Stops current recording and sends audio string to google cloud.\r\n      // recording will start again after google cloud api\r\n      // call if `continuous` prop is true. Until the api result\r\n      // returns, technically the microphone is not being captured again\r\n      stopRecording({\r\n        exportWAV: true,\r\n        wavCallback: (blob) =>\r\n          handleBlobToBase64({ blob, continuous: continuous || false })\r\n      });\r\n    });\r\n  };\r\n\r\n  const stopSpeechToText = () => {\r\n    if (recognition && !useOnlyGoogleCloud) {\r\n      recognition.stop();\r\n    } else {\r\n      setIsRecording(false);\r\n      stopMediaStream();\r\n      stopRecording({\r\n        exportWAV: true,\r\n        wavCallback: (blob) => handleBlobToBase64({ blob, continuous: false })\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleRecordingTimeout = () => {\r\n    timeoutId.current = window.setTimeout(() => {\r\n      setIsRecording(false);\r\n      stopMediaStream();\r\n      stopRecording({ exportWAV: false });\r\n    }, timeout);\r\n  };\r\n\r\n  const handleBlobToBase64 = ({\r\n    blob,\r\n    continuous\r\n  }: {\r\n    blob: Blob;\r\n    continuous: boolean;\r\n  }) => {\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(blob);\r\n\r\n    reader.onloadend = async () => {\r\n      const base64data = reader.result as string;\r\n\r\n      let sampleRate = audioContextRef.current?.sampleRate;\r\n\r\n      // Google only accepts max 48000 sample rate: if\r\n      // greater recorder js will down-sample to 48000\r\n      if (sampleRate && sampleRate > 48000) {\r\n        sampleRate = 48000;\r\n      }\r\n\r\n      const audio = { content: '' };\r\n\r\n      const config: GoogleCloudRecognitionConfig = {\r\n        encoding: 'LINEAR16',\r\n        languageCode: 'en-US',\r\n        sampleRateHertz: sampleRate,\r\n        ...googleCloudRecognitionConfig\r\n      };\r\n\r\n      const data = {\r\n        config,\r\n        audio\r\n      };\r\n\r\n      // Gets raw base 64 string data\r\n      audio.content = base64data.substr(base64data.indexOf(',') + 1);\r\n\r\n      const googleCloudRes = await fetch(\r\n        `https://speech.googleapis.com/v1/speech:recognize?key=${googleApiKey}`,\r\n        {\r\n          method: 'POST',\r\n          body: JSON.stringify(data)\r\n        }\r\n      );\r\n\r\n      const googleCloudJson = await googleCloudRes.json();\r\n\r\n      // Update results state with transcribed text\r\n      if (googleCloudJson.results?.length > 0) {\r\n        const { transcript } = googleCloudJson.results[0].alternatives[0];\r\n\r\n        setLegacyResults((prevResults) => [...prevResults, transcript]);\r\n\r\n        setResults((prevResults) => [\r\n          ...prevResults,\r\n          {\r\n            speechBlob: blob,\r\n            transcript,\r\n            timestamp: Math.floor(Date.now() / 1000)\r\n          }\r\n        ]);\r\n      }\r\n\r\n      if (continuous) {\r\n        startSpeechToText();\r\n      } else {\r\n        stopMediaStream();\r\n        setIsRecording(false);\r\n      }\r\n    };\r\n  };\r\n\r\n  const stopMediaStream = () => {\r\n    mediaStream.current?.getAudioTracks()[0].stop();\r\n  };\r\n\r\n  return {\r\n    error,\r\n    interimResult,\r\n    isRecording,\r\n    results: useLegacyResults ? legacyResults : results,\r\n    setResults,\r\n    startSpeechToText,\r\n    stopSpeechToText\r\n  };\r\n}\r\n"],"names":["audioContextType","WildEmitter","mixin","constructor","prototype","isWildEmitter","on","event","groupName","fn","this","callbacks","hasGroup","arguments","length","group","undefined","func","_groupName","push","once","self","off","apply","releaseGroup","item","i","len","handlers","splice","indexOf","emit","listeners","args","slice","call","specialCallbacks","getWildcardCallbacks","concat","eventName","split","result","window","AudioContext","webkitAudioContext","audioContext","WORKER_ENABLED","global","URL","Blob","Worker","InlineWorker","functionBody","_this","toString","trim","match","createObjectURL","type","postMessage","data","setTimeout","onmessage","bind","Recorder","[object Object]","source","cfg","config","bufferLen","numChannels","mimeType","recording","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","onaudioprocess","e","buffer","channel","inputBuffer","getChannelData","worker","command","connect","destination","sampleRate","newSampleRate","recLength","recBuffers","initBuffers","mergeBuffers","Float32Array","offset","set","writeString","view","string","setUint8","charCodeAt","record","interleaved","buffers","inputL","inputR","index","inputIndex","interleave","dataview","samples","ArrayBuffer","DataView","setUint32","setUint16","output","input","s","Math","max","min","setInt16","floatTo16BitPCM","encodeWAV","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","downSampleBuffer","audioBlob","cb","pop","callback","Error","blob","filename","url","webkitURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent","microphoneStream","rec","stopRecording","wavCallback","stop","getAudioTracks","clear","SpeechRecognition","webkitSpeechRecognition","recognition","useSpeechToText","continuous","crossBrowser","googleApiKey","googleCloudRecognitionConfig","onStartSpeaking","onStoppedSpeaking","speechRecognitionProperties","interimResults","timeout","useOnlyGoogleCloud","useLegacyResults","isRecording","setIsRecording","useState","audioContextRef","useRef","legacyResults","setLegacyResults","results","setResults","interimResult","setInterimResult","error","setError","timeoutId","mediaStream","useEffect","navigator","mediaDevices","getUserMedia","console","current","warn","startSpeechToText","async","grammars","lang","maxAlternatives","start","onresult","transcript","timestamp","floor","Date","now","isFinal","prevResults","concatTranscripts","resultIndex","onaudiostart","onend","chromeSpeechRecognition","state","resume","stream","errHandler","onStreamLoad","audio","createMediaStreamSource","err","log","startRecording","clearTimeout","handleRecordingTimeout","stopMediaStream","clone","speechEvents","options","harker","sourceNode","fftBins","analyser","smoothing","interval","threshold","play","history","running","createAnalyser","fftSize","smoothingTimeConstant","frequencyBinCount","jquery","HTMLAudioElement","HTMLVideoElement","createMediaElementSource","speaking","suspend","Object","defineProperty","get","onstatechange","setThreshold","t","setInterval","disconnect","speakingHistory","looper","currentVolume","maxVolume","getFloatFrequencyData","ii","getMaxVolume","shift","Hark","handleBlobToBase64","reader","FileReader","readAsDataURL","onloadend","base64data","content","encoding","languageCode","sampleRateHertz","substr","googleCloudRes","fetch","method","body","JSON","stringify","googleCloudJson","json","alternatives","speechBlob","stopSpeechToText","brave","isBrave","then","bool"],"mappings":"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"}